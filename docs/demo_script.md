# Snowflake MLOps ハンズオン - デモスクリプト

## 📋 概要

**所要時間**: 約90分  
**対象者**: データサイエンティスト、MLエンジニア、データエンジニア

---

## 🎯 デモのゴール

> 「Snowflake上でMLOpsの一連のワークフローを体験し、Feature Store、Experiment Tracking、Model Registryの価値を理解する」

---

## 📖 デモストーリー

### 🎭 シナリオ説明（2分）

```
📢 説明ポイント:
「皆さんは小売会社『Snow Retail』のデータサイエンティストです。
2024年前半にアクティブだった顧客の一部が、後半に離反しています。
離反しそうな顧客を事前に特定し、リテンション施策を打ちたいと考えています。」

「今日は、データ探索からモデルの本番デプロイまで、
Snowflake上でMLOpsの一連のワークフローを体験していただきます。」
```

---

## Step 0: 環境セットアップ（5分）

### 実行
1. Snowsight を開く
2. 新しいワークシートを作成
3. `setup/setup.sql` をコピー＆ペースト
4. 「Run All」で実行

### 📢 説明ポイント
```
「このスクリプト1つで、必要な環境がすべて構築されます。
- Git連携でリポジトリを登録
- データベース、コンピュートプール、ウェアハウスの作成
- CSVデータのロード
- 5つのNotebookの自動作成（コンテナランタイムで高速起動）
約2分で完了します。

💡 ポイント: NotebookはCPUコンピュートプール（コンテナランタイム）で動作します。
ウェアハウスランタイムより起動が早く、コスト効率も良いです。」
```

### 確認
- 「🎉 セットアップ完了！」が表示されることを確認

---

## Step 1: データ探索 + チャーンラベル作成（15分）

### 実行
1. **Projects → Notebooks → 01_DATA_EXPLORATION** を開く
2. セルを順番に実行

### 📢 説明ポイント

#### 1.2 データの確認
```
「まず、顧客データと注文データを確認します。
- 顧客: 3,000件（セグメント、地域など）
- 注文: 約20,000件（注文日、金額、ステータス）」
```

#### 1.4 チャーンの定義（重要！）
```
「ここがMLの重要なポイントです。
『チャーン』をどう定義するか、ビジネス要件に基づいて決めます。

今回の定義:
- 2024年前半（1-6月）に注文があった顧客のうち
- 2024年後半（7-12月）に注文がなかった顧客 = チャーン

この定義に基づいて、ラベルを作成します。」
```

#### 1.5 チャーンラベルの保存
```
「作成したラベルをテーブルに保存します。
これが後の学習データの正解ラベルになります。」
```

### 📊 UI確認ポイント
- **Data → Databases → MLOPS_HOL_DB → PREP_DATA → Tables**
  - CUSTOMERS, ORDERS, CHURN_LABELS テーブルが作成されていることを確認

---

## Step 2: Feature Store（20分）

### 実行
1. **02_FEATURE_STORE** Notebookを開く
2. セルを順番に実行

### 📢 説明ポイント

#### 2.3 特徴量の計算
```
「顧客の行動を表すRFM特徴量を計算します。
- Recency: 最終注文からの日数（長い→チャーンしやすい）
- Frequency: 注文回数（少ない→チャーンしやすい）
- Monetary: 注文金額（低い→チャーンしやすい）」
```

#### 2.4-2.6 Feature Store登録
```
「計算した特徴量をFeature Storeに登録します。

Feature Storeの利点:
- 特徴量の一元管理
- チーム間での再利用
- 学習と推論での一貫性」
```

#### 2.7 バージョン管理（v1 → v2）
```
「特徴量を追加してv2を作成します。
- v1: 基本RFM特徴量（5個）
- v2: 返品率、2024年注文金額を追加（7個）

Feature Storeではバージョン管理ができるので、
どの特徴量セットでモデルを学習したか追跡できます。」
```

### 📊 UI確認ポイント（重要！）
- **AI & ML → Feature Store** を開く
- 「CUSTOMER」Entityが登録されていることを確認
- 「CUSTOMER_FEATURES」のv1, v2が表示されることを確認

```
📢「Snowsight上でFeature Storeの内容を確認できます。
Entityと、そこに紐づくFeatureViewが一覧表示されます。
バージョンごとの特徴量の違いも確認できます。」
```

---

## Step 3: モデル学習（20分）

### 実行
1. **03_MODEL_TRAINING** Notebookを開く
2. セルを順番に実行（ハイパーパラメータチューニングに数分かかる）

### 📢 説明ポイント

#### 3.4 ハイパーパラメータチューニング（Cell 14）
```
「RandomizedSearchCVで最適なパラメータを探索します。
5パターン × 3-Fold CV = 15回の学習を自動で実行します。」
```

**💡 F1スコアを重視する理由（質問が出たら説明）**

```
Q: 「学習時にF1を重視するってどういう意味？」

A: 「良い質問です！実は2段階あります。

【ステップ1: モデル内部の学習】
- XGBoostは内部で『損失関数（logloss）』を最小化しています
- ここではF1は使っていません

【ステップ2: ハイパーパラメータ選択】
- 複数のパラメータ組み合わせで学習→評価を繰り返します
- 『どのパラメータが良いか』をF1スコアで判定します

つまり『F1を重視』= 『F1が最も高くなるパラメータを選ぶ』という意味です。

コードで言うと:
  scoring='f1'  ← ここでF1を指定

もしここが scoring='accuracy' なら、
Accuracyが最も高いパラメータを選ぶことになります。」
```

**💡 なぜAccuracyではなくF1？**

```
「チャーン予測は『クラス不均衡』問題です。
例えばチャーン率が20%の場合、
『全員アクティブ』と予測してもAccuracy 80%になってしまいます。

F1スコアは Precision（精度）と Recall（再現率）のバランスを取る指標なので、
チャーン予測に適しています。」
```

#### 3.6 Feature Importance
```
「どの特徴量が予測に重要かを可視化します。
DAYS_SINCE_LAST_ORDER（最終注文からの日数）が
最も重要な特徴量になっていることが多いです。」
```

#### 3.7 SHAP値
```
「SHAPはモデルの予測を解釈する手法です。
『なぜこの顧客がチャーンと予測されたのか？』を説明できます。
- 赤: チャーン方向に寄与
- 青: アクティブ方向に寄与」
```

---

## Step 4: Experiment Tracking（15分）

### 実行
1. **04_EXPERIMENT_TRACKING** Notebookを開く
2. セルを順番に実行

### 📢 説明ポイント

#### 💡 ハンズオンでの位置づけ（質問が出たら説明）

```
Q: 「03でハイパラチューニングしたのに、04でまた実験するのはなぜ？」

A: 「良い質問です！このハンズオンでは『各機能を独立して学ぶ』ことを目的にしています。

- 03: ハイパーパラメータの自動探索（RandomizedSearchCV）を体験
- 04: Experiment Trackingの記録・比較機能を体験

実運用では、RandomizedSearchCVの結果をExperiment Trackingに記録して
一元管理することが多いです。

今回は機能学習のため、あえて分けて実施しています。」
```

#### 4.4 実験の実行
```
「3つの異なるパラメータセットで実験を実行します。
- Baseline: デフォルトパラメータ
- DeepTree: 深い木（複雑なパターン学習）
- Conservative: 浅い木 + 低学習率（過学習防止）

各実験のパラメータとメトリクスを自動で記録します。」
```

#### 4.5 実験結果の比較
```
「実験結果を比較し、最良のモデルを選択します。
F1スコアを基準に選んでいます。」
```

### 📊 UI確認ポイント（重要！）
- **AI & ML → Experiments** を開く
- 「CHURN_PREDICTION_EXPERIMENT」を選択
- 3つのRunが表示されることを確認
- パラメータ・メトリクスの比較表を見せる

```
📢「Snowsight上で実験結果を一覧表示できます。
各Runのパラメータとメトリクスを比較し、
どのモデルが最良かを判断できます。
MLflowのような機能がSnowflake内に組み込まれています。」
```

---

## Step 5: Model Registry（10分）

### 実行
1. **05_MODEL_REGISTRY** Notebookを開く
2. セルを順番に実行

### 📢 説明ポイント

#### 5.3 モデル登録
```
「最良のモデルをModel Registryに登録します。
メトリクスやコメントも一緒に保存されます。」
```

#### 5.4 バージョン管理（v1 → v2）
```
「パラメータを改善してv2を作成します。
Feature Storeと同様に、モデルもバージョン管理できます。
- A/Bテスト
- ロールバック
- 監査
などに活用できます。」
```

#### 5.5-5.6 本番推論
```
「登録したモデルを使って、チャーンリスク顧客リストを作成します。
このリストをマーケティング部門に提供し、
リテンション施策を実行します。」
```

### 📊 UI確認ポイント（重要！）
- **AI & ML → Models** を開く
- 「CUSTOMER_CHURN_PREDICTOR」を選択
- v1, v2が表示されることを確認
- **コメント欄を確認** → 実験との紐付け情報が記載されている

```
📢「Model Registryでは、登録されたモデルの一覧、
各バージョンのメトリクス、説明などを確認できます。

💡 重要: コメント欄を見てください。
『どの実験から選んだか』『どのパラメータを使ったか』が記録されています。
これにより、『このv1モデルは、どの実験結果から作られたの？』という
追跡が可能になります。」
```

### 📊 Model Registry画面の説明スクリプト

**画面を見せながら説明:**

```
📢「これがModel Registryの画面です。
左側のツリーで MLOPS_HOL_DB → MODEL_REGISTRY → CUSTOMER_CHURN_PREDICTOR
を選択しています。」
```

**詳細セクション:**
```
📢「上部の『詳細』セクションでは、モデルの基本情報が表示されます。
- 型: ユーザーモデル（自分たちで作成したモデル）
- 作成者、作成日時なども確認できます。」
```

**モニターセクション:**
```
📢「『モニター』セクションでは、モデルの品質を追跡できます。
SQL APIの使用状況をモニタリングし、データドリフトなどを検出できます。
これは発展的な内容なので、今回は割愛します。」
```

**バージョン一覧:**
```
📢「下部の『2件のバージョン』を見てください。
- V1: 『デフォルト』タグがついています
- V2: 改善版として登録されています

『デフォルト』とは、SQLやAPIからモデルを呼び出すときに
バージョンを指定しなければ、このバージョンが使われるという意味です。

実運用では:
1. まずV1を本番投入（デフォルト）
2. V2を検証環境でテスト
3. V2の精度が良ければ、V2をデフォルトに切り替え
という流れになります。

これにより、問題があればすぐにV1にロールバックできます。
これが『バージョン管理』の価値です。」
```

**説明欄の確認:**
```
📢「右側の『説明』欄を見てください。
- V1: 『チャーン予測モデル v1 - 実験名: CHUR...』
- V2: 『チャーン予測モデル v2 - パラメータ改善...』

ここをクリックすると、どの実験から作られたか、
どのパラメータを使ったかの詳細が確認できます。
これが『追跡可能性（トレーサビリティ）』です。」
```

### 📊 実験との紐付けを確認するデモ

```
📢「実際に紐付けを確認してみましょう。

1. Model Registry → CUSTOMER_CHURN_PREDICTOR → v1 のコメントを確認
   → 『選択Run: Baseline』と記載されている

2. Experiment Tracking → CHURN_PREDICTION_EXPERIMENT を開く
   → Baseline Runの詳細を確認

3. 両方のパラメータが一致していることを確認
   → これが『追跡可能性』です」
```

---

## 📊 最終成果物の確認（5分）

### Data → Tables で確認
| テーブル | スキーマ | 説明 |
|----------|----------|------|
| CHURN_LABELS | PREP_DATA | チャーンラベル |
| TRAINING_DATASET_V1 | FEATURE_STORE | 学習データ |
| MODEL_PREDICTIONS_V1 | FEATURE_STORE | 予測結果 |
| EXPERIMENT_RESULTS | FEATURE_STORE | 実験結果 |
| **MODEL_LINEAGE** | **MODEL_REGISTRY** | **系譜情報（追跡用）** |
| CHURN_RISK_CUSTOMERS | ANALYTICS | 施策対象リスト |

### 📢 Lineage（系譜）テーブルの説明
```
📢「MODEL_LINEAGEテーブルを見てください。
ここにはMLOpsの核心である『追跡可能性』が記録されています。

このテーブルで以下が確認できます:
- どのモデルバージョンが
- どのFeature Storeバージョンを使い
- どの実験Runから選ばれたか

例えばSQLで:
  SELECT * FROM MODEL_LINEAGE WHERE MODEL_VERSION = 'v1';
と実行すると、v1モデルの全ての系譜情報が取得できます。

これが本格的なMLOpsの追跡可能性です。」
```

### 📢 まとめ
```
「本日のハンズオンで、以下を構築しました:

1. データ探索 → チャーンの定義・ラベル作成
2. Feature Store → 特徴量のバージョン管理
3. Model Training → ハイパラチューニング、SHAP解析
4. Experiment Tracking → 複数モデルの比較
5. Model Registry → モデルのバージョン管理、本番デプロイ

すべてSnowflake上で完結しています。
データの移動なし、外部ツール不要でMLOpsを実現できます。」
```

---

## 🎁 おまけ: SQLからのモデル呼び出し

```sql
-- 新しい顧客データに対してチャーン予測
SELECT 
    CUSTOMER_ID,
    MLOPS_HOL_DB.MODEL_REGISTRY.CUSTOMER_CHURN_PREDICTOR!PREDICT(
        DAYS_SINCE_LAST_ORDER,
        TOTAL_ORDER_COUNT,
        ...
    ) AS CHURN_PREDICTION
FROM CUSTOMER_FEATURES_VIEW;
```

```
📢「登録したモデルはSQLから直接呼び出せます。
BIツールやダッシュボードからも利用可能です。」
```

---

## 📋 クリーンナップ

ハンズオン終了後:
```sql
-- cleanup.sql を実行
-- すべてのリソースが削除されます
```

---

## 📚 参考リンク

- [Snowflake ML Overview](https://docs.snowflake.com/en/developer-guide/snowflake-ml/overview)
- [Feature Store](https://docs.snowflake.com/en/developer-guide/snowflake-ml/feature-store/overview)
- [Model Registry](https://docs.snowflake.com/en/developer-guide/snowflake-ml/model-registry/overview)
- [Experiments](https://docs.snowflake.com/en/developer-guide/snowflake-ml/experiments)
